diff -ruPN org-files/net/ipv6/ip6_output.c mod-files/net/ipv6/ip6_output.c
--- org-files/net/ipv6/ip6_output.c	2010-03-15 21:22:04.000000000 +0530
+++ mod-files/net/ipv6/ip6_output.c	2010-08-07 18:31:19.000000000 +0530
@@ -55,6 +55,30 @@
 #include <net/checksum.h>
 #include <linux/mroute6.h>
 
+/*xav starts*/
+ static int GlobalSoftWireMTU = 1300;
+ int overrideipv6smtu =0; /*by Default it uses actual interface pathmtu */
+ 
+ 
+ 
+ void SetSoftWireGlobalMTUinIPV6Output(int SoftPMTU)
+{
+	/*
+	  This function is called by the ip6_tunnel.c to set the pathmtu
+	  no checks are done at this end bcos its assumed that the source setting this pathmtu is
+	  doing this checks by itself before it writes to this function
+	*/
+	GlobalSoftWireMTU = SoftPMTU;
+}
+EXPORT_SYMBOL(SetSoftWireGlobalMTUinIPV6Output);
+
+void SetOverrideipv6smtu(int localoverrideipv6smtu)
+{
+	
+	overrideipv6smtu = localoverrideipv6smtu;
+}
+EXPORT_SYMBOL(SetOverrideipv6smtu);
+// moh ends
 static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 
 int __ip6_local_out(struct sk_buff *skb)
@@ -165,6 +189,10 @@
 
 int ip6_output(struct sk_buff *skb)
 {
+	// moh
+	unsigned int spmtu;
+	// moh ends
+
 	struct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));
 	if (unlikely(idev->cnf.disable_ipv6)) {
 		IP6_INC_STATS(dev_net(skb_dst(skb)->dev), idev,
@@ -173,7 +201,21 @@
 		return 0;
 	}
 
-	if ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||
+	if( skb->isthissoftwire[0] == 'a' && skb->isthissoftwire[1] == 'b' && skb->isthissoftwire[2] == 'c')
+     { /*Softwire test passed  now change the MTU (PMTU actually)*/
+	 
+	   if(unlikely (overrideipv6smtu==1 ))
+	      spmtu = GlobalSoftWireMTU;
+	    else
+		  spmtu = ip6_skb_dst_mtu(skb);	  
+	 }
+	 else
+	 {
+		 spmtu = ip6_skb_dst_mtu(skb);
+	 }
+	 		
+
+	if ((skb->len > spmtu && !skb_is_gso(skb)) ||
 				dst_allfrag(skb_dst(skb)))
 		return ip6_fragment(skb, ip6_output2);
 	else
@@ -620,7 +662,24 @@
 	hlen = ip6_find_1stfragopt(skb, &prevhdr);
 	nexthdr = *prevhdr;
 
-	mtu = ip6_skb_dst_mtu(skb);
+	//mtu = ip6_skb_dst_mtu(skb);
+		//moh
+	if( skb->isthissoftwire[0] == 'a' && skb->isthissoftwire[1] == 'b' && skb->isthissoftwire[2] == 'c')
+     { /*Softwire test passed  now change the MTU (PMTU actually)*/
+	 
+	   if(unlikely (overrideipv6smtu==1 ))
+	      mtu = GlobalSoftWireMTU;
+	    else
+		  mtu = ip6_skb_dst_mtu(skb);	   
+	
+	 }
+	 else
+	 {
+		 mtu = ip6_skb_dst_mtu(skb);
+	 }
+	  //Original code 
+	//mtu = ip6_skb_dst_mtu(skb);
+        //moh ends
 
 	/* We must not fragment if the socket is set to force MTU discovery
 	 * or if the skb it not generated by a local socket.  (This last
diff -ruPN org-files/net/ipv6/ip6_tunnel.c mod-files/net/ipv6/ip6_tunnel.c
--- org-files/net/ipv6/ip6_tunnel.c	2010-03-15 21:22:04.000000000 +0530
+++ mod-files/net/ipv6/ip6_tunnel.c	2010-08-06 18:48:07.000000000 +0530
@@ -37,7 +37,9 @@
 #include <linux/route.h>
 #include <linux/rtnetlink.h>
 #include <linux/netfilter_ipv6.h>
-
+//moh
+#include <linux/proc_fs.h> 
+//moh ends
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 
@@ -91,6 +93,45 @@
 /* lock for the tunnel lists */
 static DEFINE_RWLOCK(ip6_tnl_lock);
 
+/*Functions which handle proc filesystem I added these to handle the */
+static void  procfs_exit(void);
+static int   procfs_init(void);
+static int   show_smtu(char *buffer, char **start, off_t offset, int length);
+static int   show_toggle(char *buffer, char **start, off_t offset, int length);
+static int   write_to_smtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data);
+static int   write_to_toggle(struct file *file, const char *buffer,
+                      unsigned long count, void *data);
+ 
+/* xav disabled this bcos the concept has changed a bit of PMTU	*/			  
+extern void SetSoftWireGlobalMTU(int);
+extern void SetSoftWireToggle(int toggle);
+extern void SetSoftWireGlobalMTUinIPV6Output(int SoftPMTU);
+extern void SetSoftwireDeviceName( char array[]);
+extern void SetSoftwireDeviceName2( char array[]);
+extern void SetOverridesmtu(int);  /* IPV4 use actual or manual override*/
+extern void SetOverrideipv6smtu(int);  /* IPv6 uses actual or manual override*/
+
+extern void Setl2tpOverridesmtu(int);
+extern void SetSoftWireGloball2tpMTU(int); 
+
+struct net_device *softwire_dev;
+
+/* default smtu & toggle values as defined by the client*/
+static unsigned long smtu = 1300;
+static unsigned long ipv6smtu = 1300;
+static unsigned long toggle = 0;
+static unsigned long overrideipv6smtu =0; /* Default override is disabled*/
+static unsigned long overridesmtu =0;     /* Default override is disabled*/
+ 
+static char devicename[20] = "softwire"; 
+
+//moh l2tp section starts
+static unsigned long l2tpsmtu = 1300;
+static unsigned long l2tpoverridesmtu =0;     /* Default override is disabled*/
+//moh l2tp section ends
+
+
 static inline struct dst_entry *ip6_tnl_dst_check(struct ip6_tnl *t)
 {
 	struct dst_entry *dst = t->dst_cache;
@@ -461,6 +502,9 @@
 			       "packet!\n ", t->parms.name);
 		}
 		break;
+    /* xav  comment this line to allow ipv6 fragmentation
+	   this is generating the error and this error is handled in another function*/
+    /*	
 	case ICMPV6_PKT_TOOBIG:
 		mtu = *info - offset;
 		if (mtu < IPV6_MIN_MTU)
@@ -473,7 +517,7 @@
 			rel_info = mtu;
 			rel_msg = 1;
 		}
-		break;
+		break; */
 	}
 
 	*type = rel_type;
@@ -883,13 +927,15 @@
 	}
 	if (mtu < IPV6_MIN_MTU)
 		mtu = IPV6_MIN_MTU;
+	/*xav commenting code for ipv4 fragmentation stop*/
+	/*
 	if (skb_dst(skb))
 		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);
 	if (skb->len > mtu) {
 		*pmtu = mtu;
 		err = -EMSGSIZE;
 		goto tx_err_dst_release;
-	}
+	}*/
 
 	/*
 	 * Okay, now see if we can stuff it in the buffer as-is.
@@ -1270,6 +1316,7 @@
 		}
 		err = 0;
 		unregister_netdevice(dev);
+		/*xav Here i can remove the pointer to tunnel and proc interface if required*/
 		break;
 	default:
 		err = -EINVAL;
@@ -1480,7 +1527,8 @@
 	err = register_pernet_gen_device(&ip6_tnl_net_id, &ip6_tnl_net_ops);
 	if (err < 0)
 		goto err_pernet;
-	return 0;
+	return procfs_init();  /* Call Proc File Sytem init routines*/
+	/*return 0;*/
 err_pernet:
 	xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);
 unreg_ip4ip6:
@@ -1501,8 +1549,423 @@
 	if (xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6))
 		printk(KERN_INFO "ip6_tunnel close: can't deregister ip6ip6\n");
 
+	//moh
+	procfs_exit();
+	//moh ends
 	unregister_pernet_gen_device(ip6_tnl_net_id, &ip6_tnl_net_ops);
 }
+// Moh 
+static int show_devicename(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%s\n",devicename);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+static int show_l2tpsmtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", l2tpsmtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+static int show_smtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", smtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+
+
+static int show_ipv6smtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", ipv6smtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+static int show_toggle(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", toggle);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+static int show_overrideipv6smtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", overrideipv6smtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+
+static int show_overridesmtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", overridesmtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+static int show_l2tpoverridesmtu(char *buffer, char **start, off_t offset, int length) 
+{
+        int size;
+
+        size = sprintf(buffer, "%ld\n", l2tpoverridesmtu);
+        *start = buffer + offset;
+        size -= offset;
+        return (size > length) ? length : (size > 0) ? size : 0;
+}
+/* Expect decimal number of at most 9 digits followed by '\n' */
+static int write_to_smtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+        
+		if ( val < 68 || val > 65535) /* check for invalid values*/
+		     val = smtu;
+		
+		 
+		smtu = val;     /* mod 2^64 */
+		SetSoftWireGlobalMTU(smtu); 
+		
+		
+        return count;
+}
+
+static int write_to_l2tpsmtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+        
+		if ( val < 68 || val > 65535) /* check for invalid values*/
+		     val = l2tpsmtu;
+		
+		 
+		l2tpsmtu = val;     /* mod 2^64 */
+		SetSoftWireGloball2tpMTU(l2tpsmtu); 
+		
+		
+        return count;
+}
+
+
+/* Expect at most 20 chars followed by '\n' */
+static int write_to_devicename(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        char buf[20];
+     
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+                
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+		
+		 
+		 
+          *(buf+count-1)= '\0';  /* go back by one count to adjust the null char placement*/    
+		
+        
+	   strncpy(devicename,buf, count); 
+	   
+	   
+	   SetSoftwireDeviceName(devicename);
+	  SetSoftwireDeviceName2(devicename);
+
+		
+		
+        return count;
+}
+
+/* Expect decimal number of at most 9 digits followed by '\n' */
+static int write_to_ipv6smtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+        
+		if ( val < IPV6_MIN_MTU || val > 65535) /* check for invalid values*/
+		     val = ipv6smtu;
+		
+		ipv6smtu = val;     /* mod 2^64 */
+		
+		SetSoftWireGlobalMTUinIPV6Output(ipv6smtu);
+		
+        return count;
+}
+
+/* Expect decimal number of at most 9 digits followed by '\n' 
+  though in reality we need only 1 digit ZERO or 1 */
+static int write_to_toggle(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+				
+		if (val != 0 && val != 1) 
+ 		    val = toggle;   /*if the value read is not ZERO nor ONE 
+							in decimal then reset it to previous value*/
+			
+        	toggle= val;     /* mod 2^64 */
+		
+		SetSoftWireToggle(toggle);   /*  - Call exported function as interface*/
+		
+        return count;
+}
+
+
+/* Expect decimal number of at most 9 digits followed by '\n' 
+  though in reality we need only 1 digit ZERO or 1 */
+static int write_to_overrideipv6smtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+				
+		if (val != 0 && val != 1) 
+ 		    val = overrideipv6smtu;   /*if the value read is not ZERO nor ONE 
+										in decimal then reset it to previos value*/
+			
+        overrideipv6smtu= val;     /* mod 2^64 */
+		SetOverrideipv6smtu(overrideipv6smtu);   /*  - Call exported function as interface*/
+		
+        return count;
+}
+
+/* Expect decimal number of at most 9 digits followed by '\n' 
+  though in reality we need only 1 digit ZERO or 1 */
+static int write_to_overridesmtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+				
+		if (val != 0 && val != 1) 
+ 		    val = overridesmtu;   /*if the value read is not ZERO nor ONE 
+										in decimal then reset it to previos value*/
+			
+        	overridesmtu= val;     /* mod 2^64 */
+		
+		//dont use this  line only next line okSetSoftWireToggle(toggle);   /*  - Call exported function as interface*/
+		SetOverridesmtu(overridesmtu);
+        return count;
+}
+
+
+static int write_to_l2tpoverridesmtu(struct file *file, const char *buffer,
+                      unsigned long count, void *data) 
+{
+        unsigned long val = 0;
+        char buf[10];
+        char *endp;
+
+        if (count > sizeof(buf))
+                return -EINVAL;
+        if (copy_from_user(buf, buffer, count))
+                return -EFAULT;
+        val = simple_strtoul(buf, &endp, 10);
+        if (*endp != '\n')
+                return -EINVAL;
+				
+		if (val != 0 && val != 1) 
+ 		    val = l2tpoverridesmtu;   /*if the value read is not ZERO nor ONE 
+										in decimal then reset it to previos value*/
+			
+        	l2tpoverridesmtu= val;     /* mod 2^64 */
+		
+										/*  - Call exported function as interface*/
+		Setl2tpOverridesmtu(l2tpoverridesmtu);
+        return count;
+}
+
+static int  procfs_init(void) 
+{
+        struct proc_dir_entry *proc_softwire;
+        struct proc_dir_entry *proc_softwire_smtu;
+		struct proc_dir_entry *proc_softwire_ipv6smtu;
+		struct proc_dir_entry *proc_softwire_toggle;
+		struct proc_dir_entry *proc_softwire_devicename;
+		struct proc_dir_entry *proc_softwire_overrideipv6smtu;
+		struct proc_dir_entry *proc_softwire_overridesmtu;
+		struct proc_dir_entry *proc_softwire_l2tpsmtu;
+		struct proc_dir_entry *proc_softwire_l2tpoverridesmtu;
+		
+        proc_softwire = proc_mkdir("softwire", 0);
+        if (!proc_softwire) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire\n");
+                return -ENOMEM;
+        }
+		
+        proc_softwire_smtu = create_proc_read_entry("softwire/smtu", 0, 0, show_smtu, NULL);
+        if (!proc_softwire_smtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/smtu\n");
+                remove_proc_entry("softwire", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_smtu->write_proc = write_to_smtu;
+		
+		proc_softwire_l2tpsmtu = create_proc_read_entry("softwire/l2tpsmtu", 0, 0, show_l2tpsmtu,NULL);
+        if (!proc_softwire_l2tpsmtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/l2tpsmtu\n");
+                remove_proc_entry("softwire", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_l2tpsmtu->write_proc = write_to_l2tpsmtu;
+		
+		proc_softwire_ipv6smtu = create_proc_read_entry("softwire/ipv6smtu", 0, 0, show_ipv6smtu,NULL);
+        if (!proc_softwire_ipv6smtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/ipv6smtu\n");
+                remove_proc_entry("softwire", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_ipv6smtu->write_proc = write_to_ipv6smtu;
+        
+		proc_softwire_toggle = create_proc_read_entry("softwire/toggle", 0, 0, show_toggle, NULL);
+        if (!proc_softwire_toggle) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/toggle\n");
+                remove_proc_entry("softwire", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_toggle->write_proc = write_to_toggle;
+		
+		
+		proc_softwire_devicename = create_proc_read_entry("softwire/devicename", 0, 0, show_devicename,NULL);
+        if (!proc_softwire_devicename) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/devicename\n");
+                remove_proc_entry("devicename", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_devicename->write_proc = write_to_devicename;
+
+		
+		proc_softwire_overrideipv6smtu = create_proc_read_entry("softwire/overrideipv6smtu", 0, 0, show_overrideipv6smtu,NULL);
+		 if (!proc_softwire_overrideipv6smtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/overrideipv6smtu\n");
+                remove_proc_entry("overrideipv6smtu", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_overrideipv6smtu->write_proc = write_to_overrideipv6smtu;
+		
+		proc_softwire_overridesmtu = create_proc_read_entry("softwire/overridesmtu", 0, 0, show_overridesmtu,NULL);
+		 if (!proc_softwire_overridesmtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/overridesmtu\n");
+                remove_proc_entry("overridesmtu", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_overridesmtu->write_proc = write_to_overridesmtu;
+		
+	    proc_softwire_l2tpoverridesmtu = create_proc_read_entry("softwire/l2tpoverridesmtu", 0, 0, show_l2tpoverridesmtu,NULL);
+		 if (!proc_softwire_l2tpoverridesmtu) 
+		{
+                printk (KERN_ERR "cannot create /proc/softwire/l2tpoverridesmtu\n");
+                remove_proc_entry("l2tpoverridesmtu", 0);
+                return -ENOMEM;
+        }
+        proc_softwire_l2tpoverridesmtu->write_proc = write_to_l2tpoverridesmtu;
+		return 0;
+}
+
+static void  procfs_exit(void) 
+{
+        remove_proc_entry("softwire/smtu", 0);
+		remove_proc_entry("softwire/overridesmtu", 0);
+		remove_proc_entry("softwire/ipv6smtu", 0);
+		remove_proc_entry("softwire/overrideipv6smtu", 0);
+		remove_proc_entry("softwire/toggle", 0);
+		remove_proc_entry("softwire/l2tpsmtu", 0);
+		remove_proc_entry("softwire/l2tpoverridesmtu", 0);
+		remove_proc_entry("softwire/devicename", 0);
+        remove_proc_entry("softwire", 0);
+}
+
+
+
+//moh ends
 
 module_init(ip6_tunnel_init);
 module_exit(ip6_tunnel_cleanup);
